# DB component

## Usage

### Create a connection

	// Create a connection
	$connection = new DB\MySQLi\Connection(array(
		'host'	=> '127.0.0.1',
		'user'	=> 'root',
		'password' => 'cheese',
		'db'	=> 'test',
	));
	
### Run a query
	
	$query = new DB\Query($connection);
	
	$result = $query->run("SELECT iso_code, name, population, gdp FROM countries");
	
	
### Work with the results

Calling `DB\Query::run` returns an instance of the `DB\Result` class. This class is flexible; it's an object and has methods to get at result datasets but it can also be accessed and iterated over like an array:

	var_dump($result->hash());
	var_dump($result->transpose());
	
	foreach($result as $row) {
		var_dump($row->iso_code, $row->name, $row->population, $row->gdp);
	}
	
	var_dump($result[2]);
	var_dump(count($result));

Rows in `DB\Result` objects are always an instance of `stdClass`.

The `DB\Result` object has a few methods to make manipulating result data easier.

- `value` Return the very first column from the very first row in the result.
- `first` Returns the first row in the result. You can also use `$result[0]`.
- `hash` Access the data like an associate key => value array using the first two columns from the result.
- `transpose` Takes the first column from the result and sets it as the key in the output.
- `flatten` Remove all but one column from the result rows
- `bind` todo
- `affected` The number of rows affected (if any) by the query which generated this result.
- `id` The last autoincrement ID generated by this query.
- `columns` Similar to `array_keys()`
- `isFromTransaction` returns a boolean to indicate if the result was created from a normal query or a transaction.

Notice how there's no `numRows()` method? Because the result acts like an array, instead you can do `count($result)`.


	
### Transactions

	$trans = new DB\Transaction($connection);
	
	$trans
		->add("INSERT INTO products VALUES ('SRF002', 'Winter Scarf', 2.00)")
		->add("SET @PROD_ID = LAST_INSERT_ID()")
		->add("INSERT INTO product_gallery VALUES (@PROD_ID, 'Zoom Image')")
		->setID('GALLERY_ID')
		->add("INSERT INTO gallery_image VALUES (@GALLERY_ID, ?s)", 'scarf.jpg')
		->getID()
	;
	
	$result = $trans->commit();
	
	var_dump($result->value()); // 6
	var_dump($result->isFromTransaction()); // true
	
## Query parameters

For security and to prevent SQL inject attacks **developers must never directly insert variables into query strings**. The following example shows how to do things the bad way:

	$query->run("DELETE FROM pages WHERE page_id = ".$_GET['page_id']);

**NEVER DO THIS. I WILL SHOOT YOU IN THE KNEE IF YOU DO.**

You'd normally expect `$_GET['page_id']` to be an integer but a malicious user could change instead send ` OR 1=1` which would end up in all pages being deleted.

The `DB\Query` features a parameter parser which lets you specify placeholders in your query string where you want variables to appear. You then pass in the actual variables separately and the class safely adds them in, making sure they've been cast to a certain type and escaped properly before running them. An example shows things nicely:

	$result = $query->run("
		SELECT
			*
		FROM
			user
		WHERE
			user_id = ?i
	", $_GET['user_id']);
	
The `?i` indicates a placeholder that must be an integer. `$_GET['user_id']` is converted to an integer and the `?i` placeholder is replaced with it. There are a few different types you can cast to:

- `?i` Integer
- `?s` String (Strings are automatically wrapped with single quotes).
- `?f` Float.
- `?d` Datetime. Presumed to be an instance of the `DateTime` object. The unix timestamp representation will be used in the query. If you're dealing with SQL's `date time` fields you should instead treat it like a string.

All the placeholders can optionally have `n` added to the end e.g `?in` or `?sn`. The `n` stands for null. In this instance if the parameter passed in return `true` from the `is_null()` function then the placeholder will instead be replaced in the query as `NULL` rather being cast to the desired type.

You can also just use the `?` character on it's own as placeholder. It's equivalent to using `?sn`.

You can use multiple placeholders by passing in an array or an object as the second parameter to `run()`. The placeholders will be replaced with the matching item in the array. So for example the 5th placeholder in the query will be replaced by the 5th item in the array and so on.

	$result = $query->run("
		INSERT INTO
			staff (forename, surname, date_of_birth, monthly_wage, department_id)
		VALUES
			(?s, ?s, ?dn, ?f, ?i)
	", array(
		'Bobby',
		'Mcbillykins',
		new DateTime('12th June 1975'),
		2543.87,
		5
	));

You can also specify key names explicitly in your placeholders. This is useful if you have a large hash of data but only want to use a few of the elements in the query.

	$data = array(
		'unit_name' => 'Cardigan',
		'unit_size'	=> 'Large',
		'unit_id' => 323,
		'unit_colour' => 'Blue',
		'unit_stock' => 4,
		'unit_price' => 69.99,
	);
	
	$result = $query->run("
		INSERT INTO
			stock_snapshot (unit_id, stock_level)
		VALUES
			(:unit_id?i, :unit_stock?i)
	", $data);
	
Key names can only contain a-z, A-Z, 0-9, _ and -.


## Under the hood

The DB component makes heavy use of the composite and proxy patterns as well as PHP's inbuilt `Iterator` and `ArrayAccess` interfaces.

### Adapters

Adapters abstract away the differences between storage engines so that the `DB\Result`, and `DB\Query` classes don't need to know how the underlying DB APIs work. An adapter is made up of two classes:

- `DB\Adapter\<name>\Connection` - Maintains the connection to the data store and low level features such as escaping and running queries. It must implement `DB\Adapter\ConnectionInterface`.
- `DB\Adapter\<name>\Result` - A wrapper around the result object or array returned from `DB\Adapter\<name>\Connection`. It must implement `DB\Adapter\ResultInterface`.

Currently there are only two wrappers, `MySQLi` and `Faux`. In the future this could be expanded to cover `PostgreSQL`, `SQLite` or `Mongo`.

### Query object

The `DB\Query` object is responsible for parsing query parameters, running a query against the data store and returning a response. Multiple queries can be run against one object each returning new result sets.

### Result object

The `DB\Result` object uses PHP5's `ArrayAccess`, `Iterator` and `Countable` interfaces to make itself behave like an array. This allows developers to loop over, `count()` and access the result using indexes (e.g `$result[3]`).

`DB\Result` extends `DB\ResultArrayAccess` which provides the implements the offset accessor functionality. This class in turn extends `DB\ResultIterator` which implements the methods needed for iteration and counting. These two classes would have been great as traits but we can't use them in PHP 5.3.

## Faux Connections

For unit testing it's possible to create a connection that always returns a user defined array, what ever query is run against it.


	$connection = new DB\Adapter\Faux\Connection;
	$connection->setResult(array(
		array(
			'forename' => 'James',
			'surname' => 'Moss',
			'age'	=> 24,
		),
		array(
			'forename' => 'Joe',
			'surname' => 'Holdcroft',
			'age'	=> 20,
		),
		array(
			'forename' => 'Danny',
			'surname' => 'Hannah',
			'age'	=> 25,
		),		
	));
	$query = new DB\Query($connection);
	$result = $query->run("SELECT * FROM products");
	
	var_dump($result[1]->surname); // Holdcroft
	
It's also possible to set a series of arrays to be returned for each subsequent query:

	$connection = new DB\Adapter\Faux\Connection;
	$connection->setSequence(array(
		array(
			array(
				'id' => 5,
				'title' => 'Intro',
			),
			array(
				'id' => 6,
				'title' => 'Heading 3',
			),		
		),
		array(
			array(
				'created_at' => 122324342683,
			),
			array(
				'created_at' => 14232432683,
			),
			array(
				'created_at' => 682232222,
			),
			array(
				'created_at' => 10734222683,
			),
		),	
	));
	$query = new DB\Query($connection);
	
	$result = $query->run("SELECT * FROM page");
	var_dump(count($result)); // 2
	
	$result = $query->run("SELECT * FROM blog");
	var_dump(count($result)); // 4
	
Often, you will want to return specific data for a certain query. You can use the `setPattern` method to only return data for queries which match a regular expression

	$connection = new DB\Adapter\Faux\Connection;
	$connection->setPattern('/product\.id = 11/m', array(
		array(
			'id' => 11,
			'title' => 'Socks',
			'price' => 11.00,
			'rrp' => 15.00
		),
	));
	$query = new DB\Query($connection);
	
	$result = $query->run("SELECT * FROM product WHERE product.id = 11");
	var_dump($result[0]->title); // Socks
	
	$result = $query->run("SELECT * FROM product WHERE product.id = 13");
	var_dump($result); // false
	
Using array literals works fine when you only have a few rows to return but when using large datasets it soons become unwieldy. Instead, you can use the `ConnectionCsv` class to load data from csv files. Instead of passing arrays to the `setSequence`, `setResult` and `setPattern` methods, you instead pass the file path to a CSV file. Something important to note is that **the first row in the CSV must always contain the column headings**, these will be turned into the keys used for the resulting data rows.

	$connection = new DB\Adapter\Faux\ConnectionCsv;
	$connection->setResult('staff_members.csv');
	$query = new DB\Query($connection);
	$result = $query->run("SELECT * FROM staff");
	var_dump($result[1]->surname); // Freeman
	
You can use a series of CSV files with `setSequence` too

	$connection = new DB\Adapter\Faux\ConnectionCsv;
	$connection->setSequence(array('staff_members.csv', 'countries.csv'));
	$query = new DB\Query($connection);
	$result = $query->run("SELECT * FROM staff");
	$result = $query->run("SELECT * FROM countries");
