<?php

namespace Message\Cog\DB;

use Message\Cog\DB\Adapter\ConnectionInterface;

/**
* Query class
*
* Responsible for turning SQL queries into Result datasets.
*/
class Query
{
	protected $_connection;
	protected $_params;
	protected $_query;
	protected $_parsedQuery;

	const TOKEN_REGEX = '/((\:[a-zA-Z0-9_\-\.]*)|\?)(([a-z]+))?/';

	public function __construct(ConnectionInterface $connection)
	{
		$this->setConnection($connection);
	}

	/**
	 * Runs a query against the data store
	 *
	 * Params to be interpolated in the query can be passed in via the second
	 * parameter. See readme for more info.
	 *
	 * @param  string $query  The query to run against the datastore.
	 * @param  mixed  $params Parameters to be interpolated in the query.
	 * @return Result         The data generated by the query.
	 */
	public function run($query, $params = array())
	{
		$this->_query  = $query;
		$this->_params = (array)$params;

		$this->_parseParams();
		$result = $this->_connection->query($this->_parsedQuery);

		if($result === false) {
			throw new Exception($this->_connection->getLastError(), $this->_query);
		}

		return new Result($result, clone $this);
	}

	/**
	 * Set the connection to use for this query. Useful if you want to run the
	 * same query against multiple connections.
	 *
	 * @param ConnectionInterface $connection
	 */
	public function setConnection(ConnectionInterface $connection)
	{
		$this->_connection = $connection;
	}

	/**
	 * Replaces placeholders in the query with safe, escaped parameters. Used
	 * to prevent SQL injection attacks.
	 *
	 * @todo Move this into it's own class.
	 *
	 * @return boolean Indicates if any parsing had to be performed.
	 */
	private function _parseParams()
	{
		if(!count($this->_params)) {
			$this->_parsedQuery = $this->_query;
			return false;
		}

		$counter = 0;
		$types = array(
			's'	=> 'string',
			'i'	=> 'integer',
			'f' => 'float',
			'd'	=> 'datetime',
		);

		// PHP 5.3 hack
		$connection = $this->_connection;
		$fields = $this->_params;

		$this->_parsedQuery = preg_replace_callback(
			self::TOKEN_REGEX,
			function($matches) use($fields, $types, &$counter, $connection) {

			// parse and validate the token
			$full  = $matches[0];
			$param = isset($matches[3]) && !empty($matches[3]) ? $matches[3] : false;
			$flags = isset($matches[6]) ? $matches[6] : 'sn';
			$type  = str_replace('n', '', $flags, $useNull);

			if(!isset($types[$type])) {
				throw new Exception(sprintf('Unknown type `%s` in token `%s`', $type, $full));
			}

			// decide what data to use
			$data = null;
			if($param !== false && isset($fields[$param])) {
				$data = $fields[$param];
			} else if($param === false  && $counter < count($fields)) {
				$data = array_slice($fields, $counter, 1);
				$data = reset($data);
			}
			$counter++;

			// check for nullness
			if(is_null($data) && $useNull) {
				return 'NULL';
			}

			// santize
			settype($data, $types[$type]);
			$safe = $connection->escape($data);

			// format it ready for the query
			if($type == 'd') {
				if(ctype_digit($safe)) {
					$safe = 'FROM_UNIXTIME('.$safe.')';
				} else {
					$safe = "'".$safe."'";
				}
			} elseif($type == 's' || $type == 'f') {
				$safe = "'".$safe."'";
			}

			return $safe;
		}, $this->_query);

		return true;
	}


}